## API Report File for "@luxcium/mapping-tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

declare namespace assertions {
    export {
        isSettledResult,
        isFulfilledResult,
        isRejectedResult,
        is_Settled,
        is_SettledIso,
        is_SettledRight,
        is_SettledLeft
    }
}

// @public (undocumented)
export const awaitedMapping: typeof core.awaitedMapping_α;

// @public (undocumented)
function awaitedMapping_α<R, T>(collection: Iterable<T | Settled<T>>, transform: TransformFn<T, R>, lookup?: LookupFn<R>, validate?: ValidateFn<R>, errLookup?: ErrLookupFn): Promise<(SettledLeft | SettledRight<R>)[]>;

declare namespace constants {
    export {
        FULFILLED,
        REJECTED
    }
}
export { constants }

// @beta (undocumented)
function converToIsometricSettledResult<T>(collection: Array<PromiseSettledResult<T>>): Promise<Settled<T>[]>;

declare namespace core {
    export {
        awaitedMapping_α,
        generateMappingAsync_α,
        generateMapping_ς,
        paralellMapping_ς,
        serialMapping_α
    }
}
export { core }

// @public (undocumented)
export interface ErrLookupFn {
    // Warning: (ae-incompatible-release-tags) The symbol "__call" is marked as @public, but its signature references "OnlySideEffect" which is marked as @internal
    //
    // (undocumented)
    (reason: any, index: number, currentRejection: boolean): OnlySideEffect;
}

// @public
const FULFILLED: 'fulfilled';

// @public (undocumented)
export const generateMapping: typeof core.generateMapping_ς;

// @public (undocumented)
function generateMapping_ς<T, R>(collection: Iterable<T | Settled<T>>, transform: TransformFn<T, R>, lookup?: LookupFn<R>, validate?: ValidateFn<R>, errLookup?: ErrLookupFn): Generator<Promise<SettledLeft | SettledRight<R>>, void, unknown>;

// @public (undocumented)
export const generateMappingAsync: typeof core.generateMappingAsync_α;

// @public (undocumented)
function generateMappingAsync_α<R, T>(collection: Iterable<T | Settled<T>>, transform: TransformFn<T, R>, lookup?: LookupFn<R>, validate?: ValidateFn<R>, errLookup?: ErrLookupFn): AsyncGenerator<PromiseSettledResult<R>, void, unknown>;

// @beta (undocumented)
function getFulfilledResults<T>(collection: Array<PromiseSettledResult<T>>): PromiseFulfilledResult<T>[];

// @beta (undocumented)
function getRejectedResults<T>(collection: Array<PromiseSettledResult<T>>): PromiseRejectedResult[];

declare namespace helpers {
    export {
        assertions,
        tools
    }
}
export { helpers }

// @public (undocumented)
export interface IMappable<T = any> {
    // Warning: (ae-incompatible-release-tags) The symbol "map" is marked as @public, but its signature references "Mapper" which is marked as @internal
    //
    // (undocumented)
    map: <U = unknown>(callbackfn: Mapper<T, U>) => U[];
}

// @public (undocumented)
function is_Settled<T>(contender: any): contender is Settled<T>;

// @public (undocumented)
function is_SettledIso<T>(contender: any): contender is SettledIso<T>;

// @public (undocumented)
function is_SettledLeft(contender: any): contender is SettledLeft;

// @public (undocumented)
function is_SettledRight<T>(contender: any): contender is SettledRight<T>;

// @public (undocumented)
function isFulfilledResult<T>(contender: any): contender is PromiseFulfilledResult<T>;

// @beta (undocumented)
function isometricSettledResult<T>(item: PromiseSettledResult<T>, index?: number): Settled<T>;

// @public (undocumented)
function isRejectedResult(contender: any): contender is PromiseRejectedResult;

// @public (undocumented)
function isSettledResult<T>(contender: any): contender is PromiseSettledResult<T>;

// @beta (undocumented)
function listFulfilledResults<T>(collection: Array<PromiseSettledResult<T>>): T[];

// @public (undocumented)
export interface LookupFn<U> {
    // Warning: (ae-incompatible-release-tags) The symbol "__call" is marked as @public, but its signature references "OnlySideEffect" which is marked as @internal
    //
    // (undocumented)
    (value: U, index: number): OnlySideEffect;
}

// @beta (undocumented)
function mapFulfilledResults(): void;

// Warning: (ae-internal-missing-underscore) The name "Mapper" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type Mapper<T = any, U = unknown, A = T> = (value: T, index?: number, array?: readonly A[]) => U;

// @public (undocumented)
export interface MapperOptions<T, U> {
    // (undocumented)
    array?: (T | Settled<T>)[];
    // (undocumented)
    errLookup?: ErrLookupFn;
    // (undocumented)
    index: number;
    // (undocumented)
    item: T | Settled<T>;
    // (undocumented)
    lookup?: LookupFn<U>;
    // (undocumented)
    transform: TransformFn<T, U>;
    // (undocumented)
    validate?: ValidateFn<U>;
}

// Warning: (ae-internal-missing-underscore) The name "OnlySideEffect" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type OnlySideEffect = void;

// @public (undocumented)
export const paralellMapping: typeof core.paralellMapping_ς;

// @public (undocumented)
function paralellMapping_ς<T, R>(collection: Iterable<T | Settled<T>>, transform: TransformFn<T, R>, lookup?: LookupFn<R>, validate?: ValidateFn<R>, errLookup?: ErrLookupFn): Promise<SettledLeft | SettledRight<R>>[];

// @public
const REJECTED: 'rejected';

// @public (undocumented)
export const serialMapping: typeof core.serialMapping_α;

// @public (undocumented)
function serialMapping_α<T, R>(collection: Iterable<T | Settled<T>>, transform: TransformFn<T, R>, lookup?: LookupFn<R>, validate?: ValidateFn<R>, errLookup?: ErrLookupFn): Promise<(SettledLeft | SettledRight<R>)[]>;

// @public
export type Settled<T> = SettledLeft | SettledRight<T>;

// @public (undocumented)
export type SettledIso<T = any> = {
    fulfilled: null | T;
    rejected: any;
    value?: undefined | T;
    reason?: any;
    index: number;
} & ({
    status: 'fulfilled';
    value: T;
} | {
    status: 'rejected';
    reason: any;
});

// @public
export interface SettledLeft extends PromiseRejectedResult {
    // (undocumented)
    currentRejection: true | false | undefined;
    // (undocumented)
    fulfilled: null;
    // (undocumented)
    index: number;
    // (undocumented)
    reason: any;
    // (undocumented)
    recipeSteps: number;
    // (undocumented)
    rejected: any;
    // (undocumented)
    status: 'rejected';
    // (undocumented)
    value?: undefined;
}

// @beta (undocumented)
function settledLengts<T>(collection: Array<PromiseSettledResult<T>>): {
    fulfilled: number;
    rejected: number;
    settled: number;
};

// @public
export interface SettledRight<T> extends PromiseFulfilledResult<T> {
    // (undocumented)
    currentRejection: null;
    // (undocumented)
    fulfilled: T;
    // (undocumented)
    index: number;
    // (undocumented)
    reason?: undefined;
    // (undocumented)
    recipeSteps: number;
    // (undocumented)
    rejected: null;
    // (undocumented)
    status: 'fulfilled';
    // (undocumented)
    value: T;
}

declare namespace tools {
    export {
        mapFulfilledResults,
        converToIsometricSettledResult,
        isometricSettledResult,
        getFulfilledResults,
        listFulfilledResults,
        getRejectedResults,
        settledLengts
    }
}

// @public (undocumented)
export interface TransformFn<T, U> {
    // (undocumented)
    (value: T, index?: number, array?: readonly (T | Settled<T>)[]): Promise<U>;
}

// @public (undocumented)
export interface ValidateFn<U> {
    // Warning: (ae-incompatible-release-tags) The symbol "__call" is marked as @public, but its signature references "OnlySideEffect" which is marked as @internal
    //
    // (undocumented)
    (value: U, index: number): Promise<OnlySideEffect>;
}

```
