## API Report File for "mapping-tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

declare namespace assertions {
    export {
        isPromise,
        isPromiseLike,
        isPromiseFulfilledResult,
        isPromiseRejectedResult,
        isPromiseSettledResult,
        hasTransformStep,
        isSettled,
        isSettledLeft,
        isSettledRight
    }
}

// @public (undocumented)
export type Await<B> = PromiseLike<Base<B>>;

// @public (undocumented)
export type AwaitAndBase<B> = Base<B> | PromiseLike<Base<B>>;

// @public (undocumented)
export function awaitedMapping<T, R>(collection: Iterable<Base<T>> | PromiseLike<Iterable<Base<T>>> | Iterable<PromiseLike<Base<T>>>, transform?: TransformFn<T, R>, lookup?: LookupFn<T, R>, validate?: ValidateFn<T, R>, errLookup?: ErrLookupFn): Promise<(SettledLeft | SettledRight<R>)[]>;

// @public (undocumented)
export type Base<TBase> = TBase | Settled<TBase> | PromiseSettledResult<TBase> | SettledRight<TBase> | PromiseFulfilledResult<TBase> | SettledLeft | PromiseRejectedResult;

// @public (undocumented)
export type Collection<B> = Iterable<Base<B>>;

// @public (undocumented)
export type CollectionOfAwait<B> = Collection<Await<B>>;

declare namespace constants {
    export {
        FULFILLED,
        REJECTED
    }
}
export { constants }

// Warning: (ae-forgotten-export) The symbol "converToIsometricSettledResult_" needs to be exported by the entry point index.d.ts
//
// @beta (undocumented)
const converToIsometricSettledResult: typeof converToIsometricSettledResult_;

// @public
export interface ErrLookupFn {
    // Warning: (ae-forgotten-export) The symbol "OnlySideEffect" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    (reason: any, index: number, currentRejection: boolean): OnlySideEffect;
}

// @public
const FULFILLED: 'fulfilled';

declare namespace functions {
    export {
        awaitedMapping,
        generateMapping,
        generateMappingAsync,
        paralellMapping,
        serialMapping
    }
}
export { functions }

// @public (undocumented)
export function generateMapping<T, R>(collection: Iterable<Base<T>>, transform?: TransformFn<T, R>, lookup?: LookupFn<T, R>, validate?: ValidateFn<T, R>, errLookup?: ErrLookupFn): Generator<Promise<SettledLeft | SettledRight<R>>, void, unknown>;

// @public (undocumented)
export function generateMappingAsync<R, T>(collection: Iterable<Base<T>>, transform?: TransformFn<T, R>, lookup?: LookupFn<T, R>, validate?: ValidateFn<T, R>, errLookup?: ErrLookupFn): AsyncGenerator<Settled<R>, void, unknown>;

// @beta (undocumented)
function getRejectedResults<T>(collection: Array<Settled<T> | PromiseSettledResult<T>>): SettledLeft[];

// @public (undocumented)
function getTransformStep(item: unknown, initialTransformStep?: number): number;

// @public (undocumented)
function hasTransformStep(countender: unknown): countender is TransformStep;

declare namespace helpers {
    export {
        assertions,
        tools
    }
}
export { helpers }

// @beta (undocumented)
function isometricSettledResult<T>(item: PromiseSettledResult<T>, index?: number): Settled<T>;

// @internal (undocumented)
function isPromise<U>(element: U | Promise<U>): element is Promise<U>;

// @public (undocumented)
function isPromiseFulfilledResult<T>(contender: unknown): contender is PromiseFulfilledResult<T>;

// @internal (undocumented)
function isPromiseLike<U>(element: U | PromiseLike<U>): element is PromiseLike<U>;

// @public (undocumented)
function isPromiseRejectedResult(contender: unknown): contender is PromiseRejectedResult;

// @public (undocumented)
function isPromiseSettledResult<T>(contender: any): contender is PromiseSettledResult<T>;

// @public (undocumented)
function isSettled<T>(contender: any): contender is Settled<T>;

// @public (undocumented)
function isSettledLeft(contender: unknown): contender is SettledLeft;

// @public (undocumented)
function isSettledRight<T>(contender: unknown): contender is SettledRight<T>;

// @public (undocumented)
export interface LookupFn<S, U = unknown> {
    // (undocumented)
    (value: U, index: number, array: readonly (S | Settled<S> | PromiseSettledResult<S>)[]): OnlySideEffect;
}

// @public (undocumented)
export function paralellMapping<T, R>(collection: Iterable<Base<T>>, transform?: TransformFn<T, R>, lookup?: LookupFn<T, R>, validate?: ValidateFn<T, R>, errLookup?: ErrLookupFn): Promise<SettledLeft | SettledRight<R>>[];

// @public
const REJECTED: 'rejected';

// @public (undocumented)
export function serialMapping<T, R>(collection: Iterable<Base<T>> | PromiseLike<Iterable<Base<T>>> | Iterable<PromiseLike<Base<T>>>, transform?: TransformFn<T, R>, lookup?: LookupFn<T, R>, validate?: ValidateFn<T, R>, errLookup?: ErrLookupFn): Promise<Settled<R>[]>;

// @public
export type Settled<TBase> = SettledLeft | SettledRight<TBase>;

// @public
export type SettledLeft = PromiseRejectedResult & {
    status: 'rejected';
    reason: any;
    value?: undefined;
    rejected: any;
    fulfilled: null;
    transformStep: number;
    currentRejection: true | false | undefined;
    index: number;
};

// @beta (undocumented)
function settledLengts<T>(collection: Array<Settled<T> | PromiseSettledResult<T>>): {
    fulfilled: number;
    rejected: number;
    settled: number;
};

// @public
export type SettledRight<T> = PromiseFulfilledResult<T> & {
    status: 'fulfilled';
    value: T;
    reason?: undefined;
    fulfilled: T;
    rejected: null;
    transformStep: number;
    currentRejection: null;
    index: number;
};

declare namespace tools {
    export {
        converToIsometricSettledResult,
        getRejectedResults,
        getTransformStep,
        isometricSettledResult,
        settledLengts
    }
}

// @public (undocumented)
export interface TransformFn<T, U = unknown> {
    // (undocumented)
    (value: T, index: number, array: readonly (T | PromiseSettledResult<T>)[]): Promise<U>;
}

// @public (undocumented)
export type TransformStep = {
    transformStep: number;
};

// @public (undocumented)
export interface ValidateFn<S, U = unknown> {
    // (undocumented)
    (value: U, index: number, array: readonly (S | PromiseSettledResult<S>)[]): Promise<OnlySideEffect>;
}

```
