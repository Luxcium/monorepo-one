## API Report File for "mapping-tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

declare namespace assertions {
    export {
        isPromise,
        isPromiseLike,
        isPromiseFulfilledResult,
        isPromiseRejectedResult,
        isPromiseSettledResult,
        isSettled,
        isSettledLeft,
        isSettledRight
    }
}

// @public (undocumented)
export function awaitedMapping<R, T>(collection: Iterable<T | Settled<T>>, transform?: TransformFn<T, R>, lookup?: LookupFn<T, R>, validate?: ValidateFn<T, R>, errLookup?: ErrLookupFn): Promise<(SettledLeft | SettledRight<R>)[]>;

declare namespace constants {
    export {
        FULFILLED,
        REJECTED
    }
}
export { constants }

// Warning: (ae-forgotten-export) The symbol "converToIsometricSettledResult_" needs to be exported by the entry point index.d.ts
//
// @beta (undocumented)
const converToIsometricSettledResult: typeof converToIsometricSettledResult_;

declare namespace core {
    export {
        awaitedMapping,
        generateMapping,
        generateMappingAsync,
        paralellMapping,
        serialMapping
    }
}
export { core }

// @public (undocumented)
export interface ErrLookupFn {
    // Warning: (ae-forgotten-export) The symbol "OnlySideEffect" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    (reason: any, index: number, currentRejection: boolean): OnlySideEffect;
}

// @public
const FULFILLED: 'fulfilled';

// @public
export type FulfilledResult<T> = PromiseFulfilledResult<T>;

// @public (undocumented)
export function generateMapping<T, R>(collection: Iterable<T | Settled<T>>, transform?: TransformFn<T, R>, lookup?: LookupFn<T, R>, validate?: ValidateFn<T, R>, errLookup?: ErrLookupFn): Generator<Promise<SettledLeft | SettledRight<R>>, void, unknown>;

// @public (undocumented)
export function generateMappingAsync<R, T>(collection: Iterable<T | Settled<T>>, transform?: TransformFn<T, R>, lookup?: LookupFn<T, R>, validate?: ValidateFn<T, R>, errLookup?: ErrLookupFn): AsyncGenerator<SettledLeft | SettledRight<R>, void, unknown>;

// @beta (undocumented)
function getFulfilledResults<T>(collection: Array<Settled<T> | PromiseSettledResult<T>>): SettledRight<T>[];

// @beta (undocumented)
function getRejectedResults<T>(collection: Array<Settled<T> | PromiseSettledResult<T>>): SettledLeft[];

declare namespace helpers {
    export {
        assertions,
        tools
    }
}
export { helpers }

// @beta (undocumented)
function isometricSettledResult<T>(item: PromiseSettledResult<T>, index?: number): Settled<T>;

// @internal (undocumented)
function isPromise<T>(element: any): element is Promise<T>;

// @public (undocumented)
function isPromiseFulfilledResult<T>(contender: any): contender is PromiseFulfilledResult<T>;

// @internal (undocumented)
function isPromiseLike<T>(element: any): element is PromiseLike<T>;

// @public (undocumented)
function isPromiseRejectedResult(contender: any): contender is PromiseRejectedResult;

// @public (undocumented)
function isPromiseSettledResult<T>(contender: any): contender is PromiseSettledResult<T>;

// @public (undocumented)
function isSettled<T>(contender: any): contender is Settled<T>;

// @public (undocumented)
function isSettledLeft(contender: any): contender is SettledLeft;

// @public (undocumented)
function isSettledRight<T>(contender: any): contender is SettledRight<T>;

// @beta (undocumented)
function listFulfilledResults<T>(collection: Array<Settled<T> | PromiseSettledResult<T>>): T[];

// @public (undocumented)
export interface LookupFn<S, U = unknown> {
    // (undocumented)
    (value: U, index: number, array: readonly (S | PromiseSettledResult<S>)[]): OnlySideEffect;
}

// @alpha
function mapFulfilledResults(): void;

// Warning: (ae-internal-missing-underscore) The name "Mapper" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type Mapper<T = any, U = unknown, A = T> = (value: T, index?: number, array?: readonly A[]) => U;

// @public (undocumented)
export function paralellMapping<T, R>(collection: Iterable<T | Settled<T>>, transform?: TransformFn<T, R>, lookup?: LookupFn<T, R>, validate?: ValidateFn<T, R>, errLookup?: ErrLookupFn): Promise<SettledLeft | SettledRight<R>>[];

// @public
const REJECTED: 'rejected';

// @public
export type RejectedResult = PromiseRejectedResult;

// @public (undocumented)
export function serialMapping<T, R>(collection: Iterable<T | Settled<T>>, transform?: TransformFn<T, R>, lookup?: LookupFn<T, R>, validate?: ValidateFn<T, R>, errLookup?: ErrLookupFn): Promise<(SettledLeft | SettledRight<R>)[]>;

// @public
export type Settled<T> = SettledLeft | SettledRight<T>;

// @beta (undocumented)
export type SettledIso<T = any> = {
    fulfilled: null | T;
    rejected: any;
    value?: undefined | T;
    reason?: any;
    index: number;
} & ({
    status: 'fulfilled';
    value: T;
} | {
    status: 'rejected';
    reason: any;
});

// @public
export type SettledLeft = PromiseRejectedResult & {
    status: 'rejected';
    reason: any;
    value?: undefined;
    rejected: any;
    fulfilled: null;
    recipeSteps: number;
    currentRejection: true | false | undefined;
    index: number;
};

// @beta (undocumented)
function settledLengts<T>(collection: Array<Settled<T> | PromiseSettledResult<T>>): {
    fulfilled: number;
    rejected: number;
    settled: number;
};

// @public
export type SettledResult<T> = PromiseSettledResult<T>;

// @public
export type SettledRight<T> = PromiseFulfilledResult<T> & {
    status: 'fulfilled';
    value: T;
    reason?: undefined;
    fulfilled: T;
    rejected: null;
    recipeSteps: number;
    currentRejection: null;
    index: number;
};

declare namespace tools {
    export {
        mapFulfilledResults,
        converToIsometricSettledResult,
        getFulfilledResults,
        getRejectedResults,
        isometricSettledResult,
        listFulfilledResults,
        settledLengts
    }
}

// @public (undocumented)
export interface TransformFn<T, U = unknown> {
    // (undocumented)
    (value: T, index: number, array: readonly (T | PromiseSettledResult<T>)[]): Promise<U>;
}

// @public (undocumented)
export interface ValidateFn<S, U = unknown> {
    // (undocumented)
    (value: U, index: number, array: readonly (S | PromiseSettledResult<S>)[]): Promise<OnlySideEffect>;
}

```
