## API Report File for "mapping-tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export const assertions: typeof helpers.assertions;

declare namespace assertions_2 {
    export {
        isPromise,
        isPromiseLike,
        isPromiseFulfilledResult,
        isPromiseRejectedResult,
        isPromiseSettledResult,
        hasTransformStep,
        isSettled,
        isSettledLeft,
        isSettledRight
    }
}

// @beta (undocumented)
export function awaitedMapping<T, R>(collection: DeferredCollection<T>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null): Promise<Settled<R>[]>;

// @alpha (undocumented)
export type AwaitedMappingFn = Function & (<T, R>(collection: Collection<T> | PromiseLike<Collection<T>>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null) => Promise<Settled<R>[]>);

// @public (undocumented)
export type Base<TVal> = TVal | Settled<TVal> | PromiseSettledResult<TVal> | SettledRight<TVal> | PromiseFulfilledResult<TVal> | SettledLeft | PromiseRejectedResult;

// @public
export type BaseOrDeferred<B> = Base<B> | Deferred<B>;

// @public
export type Collection<B> = Iterable<Base<B>> | Iterable<Deferred<B>>;

// @public
export type CollectionOfDeferred<B> = Iterable<Deferred<B>>;

declare namespace constants {
    export {
        FULFILLED_2 as FULFILLED,
        REJECTED_2 as REJECTED,
        NULL_SYMBOL_2 as NULL_SYMBOL
    }
}
export { constants }

// @public (undocumented)
const _default: {
    awaitedMapping: typeof functions.awaitedMapping;
    generateMapping: typeof functions.generateMapping;
    generateMappingAsync: typeof functions.generateMappingAsync;
    parallelMapping: typeof functions.parallelMapping;
    serialMapping: typeof functions.serialMapping;
    FULFILLED: "fulfilled";
    REJECTED: "rejected";
    NULL_SYMBOL: typeof constants.NULL_SYMBOL;
    extractFulfilledValues: typeof helpers.tools.extractFulfilledValues;
    extractSettledValues: typeof helpers.tools.extractSettledValues;
    filterLeft: typeof helpers.tools.filterLeft;
    filterRight: typeof helpers.tools.filterRight;
    getTransformStep: typeof helpers.tools.getTransformStep;
    isPromise: typeof helpers.assertions.isPromise;
    isPromiseLike: typeof helpers.assertions.isPromiseLike;
    isPromiseFulfilledResult: typeof helpers.assertions.isPromiseFulfilledResult;
    isPromiseRejectedResult: typeof helpers.assertions.isPromiseRejectedResult;
    isPromiseSettledResult: typeof helpers.assertions.isPromiseSettledResult;
    hasTransformStep: typeof helpers.assertions.hasTransformStep;
    isSettled: typeof helpers.assertions.isSettled;
    isSettledLeft: typeof helpers.assertions.isSettledLeft;
    isSettledRight: typeof helpers.assertions.isSettledRight;
    assertions: typeof helpers.assertions;
    tools: typeof helpers.tools;
    helpers: typeof helpers;
    constants: typeof constants;
    functions: typeof functions;
};
export default _default;

// @public
export type Deferred<B> = PromiseLike<Base<B>>;

// @public
export type DeferredCollection<B> = Collection<B> | PromiseLike<Collection<B>>;

// @public
export interface ErrLookupFn {
    // (undocumented)
    (reason: any, index: number, currentRejection: boolean): OnlySideEffect;
}

// @public
function extractFulfilledValues<R>(settledArray: Settled<R>[]): R[];

// @public
function extractSettledValues<R>(settledArray: Settled<R>[]): (R | typeof NULL_SYMBOL_2)[];

// @public
function filterLeft<R>(settledArray: Settled<R>[]): SettledLeft[];

// @public
function filterRight<R>(settledArray: Settled<R>[]): SettledRight<R>[];

// @public (undocumented)
export const FULFILLED: typeof constants.FULFILLED;

// @public
const FULFILLED_2: 'fulfilled';

declare namespace functions {
    export {
        awaitedMapping,
        generateMapping,
        generateMappingAsync,
        parallelMapping,
        serialMapping
    }
}
export { functions }

// @beta (undocumented)
export function generateMapping<T, R>(collection: Collection<T>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null): Generator<Promise<Settled<R>>, void, unknown>;

// @beta (undocumented)
export function generateMappingAsync<R, T>(collection: Collection<T>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null): AsyncGenerator<Settled<R>, void, unknown>;

// @alpha (undocumented)
export type GenerateMappingAsyncFn = Function & (<R, T>(collection: Collection<T>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null) => AsyncGenerator<Settled<R>, void, unknown>);

// @alpha (undocumented)
export type GenerateMappingFn = Function & (<T, R>(collection: Collection<T>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null) => Generator<Promise<Settled<R>>, void, unknown>);

// @public (undocumented)
function getTransformStep(item: unknown, initialTransformStep?: number): number;

// Warning: (ae-incompatible-release-tags) The symbol "hasTransformStep" is marked as @public, but its signature references "TransformStep" which is marked as @beta
// Warning: (ae-incompatible-release-tags) The symbol "hasTransformStep" is marked as @public, but its signature references "TransformStep" which is marked as @beta
//
// @public (undocumented)
function hasTransformStep(countender: unknown): countender is TransformStep;

declare namespace helpers {
    export {
        assertions_2 as assertions,
        tools_2 as tools
    }
}
export { helpers }

// @public
function isPromise<U>(element?: U | Promise<U>): element is Promise<U>;

// @public (undocumented)
function isPromiseFulfilledResult<T>(contender: unknown): contender is PromiseFulfilledResult<T>;

// @public
function isPromiseLike<U>(element?: U | PromiseLike<U>): element is PromiseLike<U>;

// @public (undocumented)
function isPromiseRejectedResult(contender: unknown): contender is PromiseRejectedResult;

// @public (undocumented)
function isPromiseSettledResult<T>(contender: any): contender is PromiseSettledResult<T>;

// @public (undocumented)
function isSettled<T>(contender: unknown): contender is Settled<T>;

// @public (undocumented)
function isSettledLeft(contender: unknown): contender is SettledLeft;

// @public (undocumented)
function isSettledRight<T>(contender: unknown): contender is SettledRight<T>;

// @public (undocumented)
export interface LookupFn<S, U = unknown> {
    // (undocumented)
    (value: U, index: number, array: readonly (S | Settled<S> | PromiseSettledResult<S>)[]): OnlySideEffect;
}

// @public (undocumented)
export const NULL_SYMBOL: typeof constants.NULL_SYMBOL;

// @public
const NULL_SYMBOL_2: unique symbol;

// @public (undocumented)
export type NullSymbol = typeof NULL_SYMBOL_2;

// @public (undocumented)
export type OnlySideEffect = void | undefined;

// @beta (undocumented)
export function parallelMapping<T, R>(collection: Collection<T>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null): Promise<Settled<R>>[];

// @alpha (undocumented)
export type ParallelMappingFn = Function & (<T, R>(collection: Collection<T>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null) => Promise<Settled<R>>[]);

// @public (undocumented)
export const REJECTED: typeof constants.REJECTED;

// @public
const REJECTED_2: 'rejected';

// @beta (undocumented)
export function serialMapping<T, R>(collection: DeferredCollection<T>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null): Promise<Settled<R>[]>;

// @alpha (undocumented)
export type SerialMappingFn = Function & (<T, R>(collection: Collection<T> | PromiseLike<Collection<T>>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null) => Promise<Settled<R>[]>);

// @public
export type Settled<T> = SettledLeft | SettledRight<T>;

// @public (undocumented)
export type SettledArray<R> = Settled<R>[];

// @public
export type SettledLeft = PromiseRejectedResult & {
    status: 'rejected';
    reason: any;
    value?: undefined;
    rejected: any;
    fulfilled: null;
    transformStep: number;
    currentRejection: true | false | undefined;
    index: number;
};

// @public
export type SettledRight<T> = PromiseFulfilledResult<T> & {
    status: 'fulfilled';
    value: T;
    reason?: undefined;
    fulfilled: T;
    rejected: null;
    transformStep: number;
    currentRejection: null;
    index: number;
};

// @public (undocumented)
export type SettledValue<R> = R | NullSymbol;

// @public (undocumented)
export type SettledValues<R> = SettledValue<R>[];

// @public (undocumented)
export const tools: typeof helpers.tools;

declare namespace tools_2 {
    export {
        extractFulfilledValues,
        extractSettledValues,
        filterLeft,
        filterRight,
        getTransformStep
    }
}

// @public (undocumented)
export interface TransformFn<T, U = unknown> {
    // (undocumented)
    (value: T, index: number, array: readonly (T | PromiseSettledResult<T>)[]): Promise<U>;
}

// @beta (undocumented)
export type TransformStep = {
    transformStep: number;
};

// @public (undocumented)
export interface ValidateFn<S, U = unknown> {
    // (undocumented)
    (value: U, index: number, array: readonly (S | PromiseSettledResult<S>)[]): Promise<OnlySideEffect>;
}

```
