## API Report File for "mapping-tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

declare namespace assertions {
    export {
        isPromise,
        isPromiseLike,
        isPromiseFulfilledResult,
        isPromiseRejectedResult,
        isPromiseSettledResult,
        hasTransformStep,
        isSettled,
        isSettledLeft,
        isSettledRight
    }
}

// @alpha
export function awaitedMapping<T, R>(collection: DeferredCollection<T>, transformFn?: null | TransformFn<T, R>, lookupFn?: null | LookupFn<T, R>, validateFn?: null | ValidateFn<T, R>, errLookupFn?: null | ErrLookupFn): Promise<Settled<R>[]>;

// @alpha (undocumented)
export type AwaitedMappingFn = Function & (<T, R>(collection: Collection<T> | PromiseLike<Collection<T>>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null) => Promise<Settled<R>[]>);

// @public (undocumented)
export type Base<TVal> = TVal | Settled<TVal> | PromiseSettledResult<TVal> | SettledRight<TVal> | PromiseFulfilledResult<TVal> | SettledLeft | PromiseRejectedResult;

// @public
export type BaseOrDeferred<B> = Base<B> | Deferred<B>;

// @public
export type Collection<B> = Iterable<Base<B>> | Iterable<Deferred<B>>;

// @public
export type CollectionOfDeferred<B> = Iterable<Deferred<B>>;

declare namespace constants {
    export {
        FULFILLED_2 as FULFILLED,
        REJECTED_2 as REJECTED,
        NULL_SYMBOL_2 as NULL_SYMBOL
    }
}
export { constants }

// Warning: (ae-forgotten-export) The symbol "converToIsometricSettledResult_" needs to be exported by the entry point index.d.ts
//
// @beta (undocumented)
const converToIsometricSettledResult: typeof converToIsometricSettledResult_;

// @public
export type Deferred<B> = PromiseLike<Base<B>>;

// @public
export type DeferredCollection<B> = Collection<B> | PromiseLike<Collection<B>>;

// @public
export interface ErrLookupFn {
    // (undocumented)
    (reason: any, index: number, currentRejection: boolean): OnlySideEffect;
}

// @public
function extractFulfilledValues<R>(settledArray: Settled<R>[]): R[];

// @public
function extractSettledValues<R>(settledArray: Settled<R>[]): (R | typeof NULL_SYMBOL_2)[];

// @public
function filterLeft<R>(settledArray: Settled<R>[]): SettledLeft[];

// @public
function filterRight<R>(settledArray: Settled<R>[]): SettledRight<R>[];

// @public (undocumented)
export const FULFILLED: typeof constants.FULFILLED;

// @public
const FULFILLED_2: 'fulfilled';

declare namespace functions {
    export {
        awaitedMapping,
        generateMapping,
        generateMappingAsync,
        paralellMapping,
        serialMapping
    }
}
export { functions }

// @alpha
export function generateMapping<T, R>(collection: Collection<T>, transformFn?: null | TransformFn<T, R>, lookupFn?: null | LookupFn<T, R>, validateFn?: null | ValidateFn<T, R>, errLookupFn?: null | ErrLookupFn): Generator<Promise<Settled<R>>, void, unknown>;

// @alpha
export function generateMappingAsync<R, T>(collection: Collection<T>, transformFn?: null | TransformFn<T, R>, lookupFn?: null | LookupFn<T, R>, validateFn?: null | ValidateFn<T, R>, errLookupFn?: null | ErrLookupFn): AsyncGenerator<Settled<R>, void, unknown>;

// @alpha (undocumented)
export type GenerateMappingAsyncFn = Function & (<R, T>(collection: Collection<T>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null) => AsyncGenerator<Settled<R>, void, unknown>);

// @alpha (undocumented)
export type GenerateMappingFn = Function & (<T, R>(collection: Collection<T>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null) => Generator<Promise<Settled<R>>, void, unknown>);

// @beta (undocumented)
function getRejectedResults<T>(collection: Array<Settled<T> | PromiseSettledResult<T>>): SettledLeft[];

// @public (undocumented)
function getTransformStep(item: unknown, initialTransformStep?: number): number;

// Warning: (ae-incompatible-release-tags) The symbol "hasTransformStep" is marked as @public, but its signature references "TransformStep" which is marked as @beta
// Warning: (ae-incompatible-release-tags) The symbol "hasTransformStep" is marked as @public, but its signature references "TransformStep" which is marked as @beta
//
// @public (undocumented)
function hasTransformStep(countender: unknown): countender is TransformStep;

declare namespace helpers {
    export {
        assertions,
        tools
    }
}
export { helpers }

// @beta (undocumented)
function isometricSettledResult<T>(item: PromiseSettledResult<T>, index?: number): Settled<T>;

// @internal (undocumented)
function isPromise<U>(element: U | Promise<U>): element is Promise<U>;

// @public (undocumented)
function isPromiseFulfilledResult<T>(contender: unknown): contender is PromiseFulfilledResult<T>;

// @internal (undocumented)
function isPromiseLike<U>(element: U | PromiseLike<U>): element is PromiseLike<U>;

// @public (undocumented)
function isPromiseRejectedResult(contender: unknown): contender is PromiseRejectedResult;

// @public (undocumented)
function isPromiseSettledResult<T>(contender: any): contender is PromiseSettledResult<T>;

// @public (undocumented)
function isSettled<T>(contender: any): contender is Settled<T>;

// @public (undocumented)
function isSettledLeft(contender: unknown): contender is SettledLeft;

// @public (undocumented)
function isSettledRight<T>(contender: unknown): contender is SettledRight<T>;

// @public (undocumented)
export interface LookupFn<S, U = unknown> {
    // (undocumented)
    (value: U, index: number, array: readonly (S | Settled<S> | PromiseSettledResult<S>)[]): OnlySideEffect;
}

// @public (undocumented)
export const NULL_SYMBOL: typeof constants.NULL_SYMBOL;

// @public
const NULL_SYMBOL_2: unique symbol;

// @public (undocumented)
export type NullSymbol = typeof NULL_SYMBOL_2;

// @public (undocumented)
export type OnlySideEffect = void | undefined;

// @alpha
export function paralellMapping<T, R>(collection: Collection<T>, transformFn?: null | TransformFn<T, R>, lookupFn?: null | LookupFn<T, R>, validateFn?: null | ValidateFn<T, R>, errLookupFn?: null | ErrLookupFn): Promise<Settled<R>>[];

// @alpha (undocumented)
export type ParalellMappingFn = Function & (<T, R>(collection: Collection<T>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null) => Promise<Settled<R>>[]);

// @public (undocumented)
export const REJECTED: typeof constants.REJECTED;

// @public
const REJECTED_2: 'rejected';

// @alpha
export function serialMapping<T, R>(collection: DeferredCollection<T>, transformFn?: null | TransformFn<T, R>, lookupFn?: null | LookupFn<T, R>, validateFn?: null | ValidateFn<T, R>, errLookupFn?: null | ErrLookupFn): Promise<Settled<R>[]>;

// @alpha (undocumented)
export type SerialMappingFn = Function & (<T, R>(collection: Collection<T> | PromiseLike<Collection<T>>, transformFn?: TransformFn<T, R> | null, lookupFn?: LookupFn<T, R> | null, validateFn?: ValidateFn<T, R> | null, errLookupFn?: ErrLookupFn | null) => Promise<Settled<R>[]>);

// @public
export type Settled<T> = SettledLeft | SettledRight<T>;

// @public (undocumented)
export type SettledArray<R> = Settled<R>[];

// @public
export type SettledLeft = PromiseRejectedResult & {
    status: 'rejected';
    reason: any;
    value?: undefined;
    rejected: any;
    fulfilled: null;
    transformStep: number;
    currentRejection: true | false | undefined;
    index: number;
};

// @beta (undocumented)
function settledLengts<T>(collection: Array<Settled<T> | PromiseSettledResult<T>>): {
    fulfilled: number;
    rejected: number;
    settled: number;
};

// @public
export type SettledRight<T> = PromiseFulfilledResult<T> & {
    status: 'fulfilled';
    value: T;
    reason?: undefined;
    fulfilled: T;
    rejected: null;
    transformStep: number;
    currentRejection: null;
    index: number;
};

// @public (undocumented)
export type SettledValue<R> = R | NullSymbol;

// @public (undocumented)
export type SettledValues<R> = SettledValue<R>[];

declare namespace tools {
    export {
        converToIsometricSettledResult,
        extractFulfilledValues,
        extractSettledValues,
        filterLeft,
        filterRight,
        getRejectedResults,
        getTransformStep,
        isometricSettledResult,
        settledLengts
    }
}

// @public (undocumented)
export interface TransformFn<T, U = unknown> {
    // (undocumented)
    (value: T, index: number, array: readonly (T | PromiseSettledResult<T>)[]): Promise<U>;
}

// @beta (undocumented)
export type TransformStep = {
    transformStep: number;
};

// @public (undocumented)
export interface ValidateFn<S, U = unknown> {
    // (undocumented)
    (value: U, index: number, array: readonly (S | PromiseSettledResult<S>)[]): Promise<OnlySideEffect>;
}

```
