Based on the transcription of the « React visually explained: 'use client' » video on YouTube by @Delba

https://youtu.be/eO51VVCpTk0?si=2oIOgeCu_hsDpvL4

Description: 

What 'use client' is, why it exists, how it works, and how to use it.

The 'use client' directive introduces a new dimension to bundling: allowing developers to use the same language and JSX component model for UI concerns that span the client and server. Replacing network synchronization code in multiple languages, routing systems, and frameworks with simple components and props.

This is an excerpt from a conference talk I gave at React Universe.


***

Here’s the text without the timestamps:

the use client directive introduces a new dimension to bundling allowing you as the developer to use the same language in jsx component model for UI concerns that spun both the client and the server it replaces Network synchronization code in multiple languages routing systems and Frameworks instead you use Simple components in props this change has sometimes been dubbed as complex and difficult but I want to challenge that notion because I think some of the confusion comes from the lack of familiarity and also understanding the kind of problems that use client solves in this talk we will explore what use client is why it exists how it works and how you can start using it first let’s quickly Define bundling during development we optimize our code for developer productivity breaking it up into separate files or modules we export and import code as needed to compose more complex functional then when we build in deployer application we optimize it for the computers it will eventually run on we follow a module dependency graph and reassemble related code into a single piece we call this process bundling during bundling we may also choose to slice our single bundle into smaller chunks for example we might code split by rout in tree Shake unused relationships this means that when a specific route is visited only the code needed for the route is loaded on the client but a web app doesn’t solely run on the client it’s a program that runs across two computers the server and the client separated by what we call a network boundary so we might also choose to breake up the bundle by environment and distribute code to ID computer to take advantage of its unique capabilities these capabilities are determined by when and where code runs the server usually runs on the computer the developer controls it could either be a runtime server that processes every incoming request or as an optimization oftime server that runs ahead of time and serves cash results this means server code can efficiently access data for example reading files from the file system directly connecting to a database or minimizing latency by positioning a server close to its data source server code can contain sensitive information like API credentials or authentication logic run exclusively on the server only sending the computered result to the client for example if you use a heavy markdown passing library on the server you only need to return the rendered result as a string to the client server code can perform tasks in advance before the user’s initial request like pre-rendering a page and caching it these capabilities mean that certain tasks are better handled by the server rather than the client on the other hand the client runs on the computer the user control specifically their web browser this means with client code you can access the browser’s Dom in apis for example to observe if a element has entered the user’s viewport you can also access user State to open or close a drop down or browser state to check the user current scroll position client code allows you to respond instantly to user interaction let’s say the user wants to expand or read more that can be done instantly without having to do a round trip to the server again this means that some tasks are better handled by the client rather than the server ideally if we had complete autonomy each tiny unit of functionality will be moved to the most appropriate environment and phase but in reality disconnect actually be quite difficult to implement in a single application especially in traditional architectures where the server code and the client code use a different programming language routing system and ecosystem all together any functionality that crosses the network boundary requires synchronization code to manage the handoff between both sides it becomes even more complicated with both in less type safe when you also have to cross a technology boundary at the same time even in x gu which uses the same language in router on both sides there’s still a lot of ceremony to wire up the nexts server with the react client World passing information from server to client involves creating an API route stinking types requesting the data updating local state and more abstractions like get serice side props react query and trpc help but they all exist to bridge the gap between different models the latest changes in react aim to address this problem by extending its component model in jsx syntax to the server react can now manage both sides of the network within the same Paradigm passing information from server to client becomes as simple as importing a component nesting it in passing props similarly if you want to send data from the client to the server it becomes as easy as importing a function and calling it also known as server actions and since we’re using JavaScript Imports crossing the network boundary is type safe by default we can hover over function from the opposite world see the inline documentation and quickly jump to its definition just like how jsx helped break down the artificial boundary between HTML CSS in JavaScript reactor is now breaking down the barrier between UI concerns that across the network using the same language for both environments means our bundler now needs a way to distinguish between server and client code so it can produce an optimized bundle for each environment but how do we tell our bundler about the server client boundary well since every web apps life cycle starts on a server computer either a bu time one when you deploy or a runtime one when the user visits your application a server for framework like nextjs might logically also start route entry points in the server environment this means that any routes created by the developer will be imported by the framework into the server environment and if the route Imports all the modules they will also be brought into the server environment however we also want to take advantage of the client computer so we need a way to Mark where the server code ends and the client code begins in react the use client directive serves this purpose by adding the directive to the top of a file we’re creating a boundary between server run code and client run code you can think of use client as a doorway from our starting point the server world into the client world we simply choose at which point in each import chain we want to open the door this leads us nicely to some practical examples of how to use use client first it’s a common misunderstanding to believe used client must be added to every file that should run on the client there is nothing wrong with this but in practice we only need to Mark each entry point once for example adding use client to page.js marks the module as a client entry point importing the my comp component into page.js brings it into the client environment adding or removing us client in ajs has no additional bundling effect on my comp because it’s already part of the client environment so in summary modules become a part of whichever environment they are imported into now let’s explore what happens when we import from a client module into a server module we’ll start by importing a simple numeric value from .js into page.js as a reminder both files are currently client modules so if we console log my INT in both modules it logs the same value twice this is expected since JavaScript is typically used in a single environment but now let’s change page.js to be a server module by moving us client down the tree this means we’re now importing from a client module into a server module if we console log again in the client environment my in logs one two 3 as expected but in the server environment my int logs something about react.client. reference with an ID that points to the file in export name this is an internal react detail but it shows that code imported across a used client boundary is a reference pointing to something rather than the actual thing in the same way when we import a client component into a server module we are importing a reference to the component the component itself is only rendered once we get to the client environment now let’s talk about use server we might naively assume you server is the opposite of used client a way to Mark server components however in reality it serves a slightly different purpose after the initial response from the server You may wish to allow the user to change or mutate data traditionally we would create a serers side API inpoint privately connect to a database securely process the change manage the communication between the client and the server and share types this can be simplified with VI server which can be used to Mark server side functions that can be called from client side code behind the scenes react will internally handle the communication layer so while use client in new server above doorways into the other world they are different because of the request response life cycle so when you’re going from the server to the client world with use client react runs all the server code in the server environment maintains a reference to any client components it finds and serializes any props that have to travel to the client world then once in the client environment it picks up where it left off and runs the remaining client Cod on the other hand when you’re going from the client world to the server world with use server react keeps code on the server but exposes a way for the client to cool it just like how react abstracted a way updating the browser’s Dom react now abstracts A Way crossing the network next let’s discuss nesting server components inside client components as we learned earlier importing a module into the client environment turns it into a client module this makes it impossible to import a server component into a client module theoretically perhaps we could use the use server directive to opt a client module back into the server environment however react doesn’t support this because it would create a server client server rendering waterfall for example react on the server renders server component might page but leaves the reference to client component a for the client then reactor on the client starts rendering client component a only to discover that it has to go back to the server to render server component B this Behavior means rendering the page could take multiple server round trips which is going to be very slow to render so instead react supports passing server components to client components as props this way react can render all server components including those pass to the client components in a single render pass on the server before handing off to the client this avoids multiple round trips but allows us to visually Place wi rendered in the server environment inside UI rendered in the client environment for example we can ask a card component that patches data on the server inside a modor component that uses local state to toggle visibility or we can EST server components inside client side context providers like them providers without having to move the whole application to the client bundle so far we have repeatedly mentioned that client components run in the client environment you would be forgiven for thinking that client components run exclusively on the client aka the browser and never on the server but in reality client components can also be pre-rendered on the server it’s confusing I know let’s discuss why if client say JavaScript is responsible for rendering the initial HTML the browser doesn’t have anything useful to show to the users until the JavaScript is downloaded passed and executed so as an optimization for the initial visit to a site we might choose to pre-execution HTML document and not an image the user can passively consume the content scroll around and even perform HTML native actions like clicking links in submitting forms in the background react hydrates the page making it fully interactive if content is shared between users that is content doesn’t change we might even choose to pre-render ahead of time at bu time rather than at runtime for every request so while client components are Tim destined to be rendered on the client they may also be pre-rendered on the server to improve the loading experience of the initial visit to a page in conclusion react on the client allows developers to break down complex UI into simple isolated Lego blocks that can be combined to form larger pieces however front end UI often depends on server side logic which is usually in a different system this makes bu in front end UI more like trying to compose Lego blocks with meano pieces react on the server aims to unify these concerns under a single model developers can use Imports props components inactions and then behind the scenes react will run code in the correct environment at the right time produce the appropriate output suspend and streamling the result and then reassemble everything back together into the final UI what happens under the hood is actually quite complex but what we are exposed to as developers is much simpler of course that is not to say that there won’t be trade-offs and new challenges there’s still a lot of rough edges and unanswered questions but I think the react team is on to something here and I’m excited to see where this goes now it should be noted that react shift to the server addresses the backend side of UI concerns it’s not trying to replace specialist backend languages and Frameworks apps have backend needs not directly related to serving UI this is where a lot of these tools shine.

More info on the author:
www.youtube.com/@Delba
