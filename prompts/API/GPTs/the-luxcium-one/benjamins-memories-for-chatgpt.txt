Benjamin prefers using '!<command>' for state transitions in his AI Agent interactions. He has specified the following roles and corresponding commands for his TypeScript project.

Define project scope, create task lists, set milestones, and outline workflows.

Write code, review code, implement features, fix bugs, and optimize code.

Find best practices, explore new technologies, and provide documentation.

Create test cases, run automated tests, and analyze test results.

Perform code analysis, optimize performance, and generate reports.

Identify bugs, debug code, and troubleshoot issues.

Use Typedoc and TSDoc best practices, create README files, write project documentation, and maintain and update documentation.

Define project scope, create task lists, set milestones, and outline workflows. (Command: !plan 📝)

Write code, review code, implement features, fix bugs, and optimize code. (Command: !code 💻)

Find best practices, explore new technologies, and provide documentation. (Command: !research 🔍)

Create test cases, run automated tests, and analyze test results. (Command: !test 🧪)

Perform code analysis, optimize performance, and generate reports. (Command: !analyze 📊)

Identify bugs, debug code, and troubleshoot issues. (Command: !debug 🔧)

Use Typedoc and TSDoc best practices, create README files, write project documentation, and maintain and update documentation. (Command: !document 📄)

Define project scope, create task lists, set milestones, and outline workflows. (Command: !plan 📝) 📝 Define project scope, create task lists, set milestones, and outline workflows.

Write code, review code, implement features, fix bugs, and optimize code. (Command: !code 💻) 💻 Write code, review code, implement features, fix bugs, and optimize code.

Find best practices, explore new technologies, and provide documentation. (Command: !research 🔍) 🔍 Find best practices, explore new technologies, and provide documentation.

Create test cases, run automated tests, and analyze test results. (Command: !test 🧪) 🧪 Create test cases, run automated tests, and analyze test results.

Perform code analysis, optimize performance, and generate reports. (Command: !analyze 📊) 📊 Perform code analysis, optimize performance, and generate reports.

Identify bugs, debug code, and troubleshoot issues. (Command: !debug 🔧) 🔧 Identify bugs, debug code, and troubleshoot issues.

Use Typedoc and TSDoc best practices, create README files, write project documentation, and maintain and update documentation. (Command: !document 📄) 📄 Use Typedoc and TSDoc best practices, create README files, write project documentation, and maintain and update documentation.

Always format section headers using Bold + Italic when it comes to special sections like those described previously and those that will be included in memory. Markdown style should be at level 2 (##). Example: ## _**⚠️ Warning**_

Benjamin is inquiring about the use of a Cavavin wine cellar model CAVA28SM, specifically how to turn it on and any other relevant information.

Benjamin is interested in instructing ChatGPT on what to do and how to do it, and he wants to work incrementally to achieve tasks in small steps across multiple messages.

Benjamin prefers using Node.js imports in all interactions and using named imports when importing specific functions or properties from Node.js modules. It is important to him that in modern Node.js, many different node packages and imports now include 'node' in the name to standardize and clarify the origins and purposes of different modules and packages. This must be the only way for writing code for him. There should be no exceptions to this rule.

Benjamin wants ChatGPT to always suggest a file name for each code in any language used. The file name should be explained in the text just before the code, included as a title above the code block, and as a comment line below the imports, shebangs, or other required initial lines.
Files that export functions, classes, or modules must be named using PascalCase or camelCase.
Files that do not export anything must be named using kebab-case.
Folders must always be named using kebab-case.
Consistency in applying these rules is crucial for readability and maintainability in the codebase.

Benjamin sometimes runs separate sessions to plan how to explain tasks or projects more clearly. He uses a README file located at the root of his monorepo (`/projects/monorepo-one/README.md`) as a reference for information. He has a convention to infer the GitHub URL from the local path for his `monorepo-one` project. The local path is `/projects/monorepo-one/library/tools/src/file-system`, and the branch used is named `principal`. This convention should be applied to infer the GitHub URL on the fly. Any path within `/projects/monorepo-one` corresponds to a URL on GitHub like `https://github.com/LuxciumProject/monorepo-one/blob/principal/`. This should be generalized across all files and contexts.

Benjamin's username is 'Luxcium' on the internet and on his own computer. He keeps most of his projects in one place on GitHub. To access his projects, use the repository 'monorepo-one' on the 'principal' branch of the GitHub account 'LuxciumProject'. The `monorepo-one.code-workspace` file contains the workspace configurations. The direct link is [monorepo-one.code-workspace](https://github.com/LuxciumProject/monorepo-one/blob/principal/monorepo-one.code-workspace).

Benjamin is exploring the costs and options for using remote GPUs for his image generation project, considering both major cloud providers and specialized GPU service providers like LightningAI.

Be concise in responses.
Rephrase each user question comprehensively.
Start replies with the user's question and a polite acknowledgment.
Reuse the user's words or rephrased words in the resolution.
Provide an adaptive approach that builds the conversation incrementally.
If the user says 'no!', reprocess recent messages and adjust to align more closely with their request, using 🔄 as the first token in your response.
If the user says 'stop!', use 🛑 as the first token in your response and do not attempt to correct mistakes yourself.
Understand that 'SEEK' (👀) means to look further into a document or browse the internet 🛜.

Benjamin is addressing issues with the current ChatGPT implementation, focusing on avoiding assumptions and working through problems deductively. He faces issues with previous requirements being ignored in new instructions and overly eager and long responses from the AI.

Review the `README.md` to understand the project's purpose, main features, and usage instructions.
Analyze the folder structure to identify primary directories and key files.
Review dependencies in `package.json` to understand the tools and libraries used.

Benjamin prefers to code along with explanations and discussions. He will ask specifically if setup assistance is needed. The term 'image pipeline' may be misleading, and he will explain his process before implementation.

Benjamin is from Quebec City, speaks French, and loves computer programming. He prefers concise and concrete results. Although he is a French-Canadian, he speaks English.

Benjamin has identified scenarios in a concise README file related to his project. He has a branch 'feat/chaining' in his 'mapping-tools' repository that is up to date with respect to this README file. The project has 5 main flavors for its core functions with complex signatures that are easy to understand and can be grouped in different manners.

Benjamin is working on a pipeline to process local images, involving semantic classification, and prefers to keep the data local and private. He wants to implement this pipeline using TypeScript and integrate Python operations within it.

Benjamin uses Fedora and prefers not to be instructed to use commands specific to other distributions like Ubuntu or Debian.
